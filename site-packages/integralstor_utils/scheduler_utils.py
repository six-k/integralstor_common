from integralstor_utils import config, db, command, audit
import crontab
import cron_descriptor
import re
import time
import datetime
import socket
import getpass
import os
import shutil


def create_cron_task(command, description, min="1", hour='*', day='*', dow='*', month='*', user='root'):
    cron_task_id = None
    try:
        if not command or not description:
            raise Exception('Invalid parameters')

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        cmd = [
            'insert into cron_tasks(command,description) values (?,?)', (command, description)]
        cron_task_id, err = db.execute_iud(db_path, [cmd], get_rowid=True)
        if err:
            raise Exception(err)

        log_path, err = config.get_log_folder_path()
        if err:
            raise Exception(err)
        log_dir = '%s/cron_logs' % log_path
        if not os.path.isdir(log_dir):
            os.mkdir(log_dir)
        log_file = '%s/%d.log' % (log_dir, cron_task_id)
        command = '%s >> %s 2>&1' % (command, log_file)

        cron = crontab.CronTab(user)
        job = cron.new(command=command, comment='%d' % cron_task_id)
        job.setall(min, hour, day, dow, month)
        if job.is_valid():
            job.enable()
            cron.write()
        else:
            raise Exception('Cron entry not valid.')

    except Exception, e:
        return None, 'Error creating cron entry : %s' % str(e)
    else:
        return cron_task_id, None


def update_cron_schedule(cron_task_id=None, user='root', min='0', hour='0', day='*', dow='*', month='*'):
    """Update schedule of a specific crontab entry(not the cron_tasks table entry)

    """
    try:
        if cron_task_id is None:
            raise Exception('cron_task_id required')
        found = False

        cron = crontab.CronTab(user)
        # can not use 'jobs = cron.find_comment(str(cron_task_id))' since it
        # returns True always
        if cron:
            for entry in cron:
                if entry.comment == str(cron_task_id):
                    found = True
                    entry.setall(min, hour, day, dow, month)
                    if entry.is_valid():
                        entry.enable()
                        cron.write()
                    else:
                        raise Exception('Cron entry not valid.')
        if not found:
            raise Exception(
                'Found no matching entry with comment string %s' % str(cron_task_id))

    except Exception, e:
        return None, 'Error updating cron entry: %s' % str(e)
    else:
        return True, None


def get_cron_tasks(cron_task_id=None, user='root'):
    """Function to return all the user created cron."""
    cron_list = []
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        if cron_task_id is None:
            query = 'select * from cron_tasks'
        else:
            query = 'select * from cron_tasks where cron_task_id=%s' % cron_task_id

        cron_db_entries, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)

        if cron_db_entries:
            cron = crontab.CronTab(user)
            for cron_db_entry in cron_db_entries:
                cron_dict = {}
                cron_dict['description'] = cron_db_entry['description']
                cron_dict['cron_task_id'] = cron_db_entry['cron_task_id']
                jobs = cron.find_comment(str(cron_db_entry['cron_task_id']))
                if jobs:
                    for job in jobs:
                        cron_dict['schedule_description'] = job.description(
                            use_24hour_time_format=True)
                        cron_dict['job'] = job
                        break
                cron_list.append(cron_dict)
    except Exception, e:
        return None, 'Error listing all cron entries : %s' % str(e)
    else:
        return cron_list, None


def is_task_running(cron_task_id, task_type_id, check_execution=False):
    """Check if any entry in the tasks table with cron_task_id has
    status field value as 'running'

    args:       cron_task_id of integer type
                task_type_id of integer type
                check_execution of boolean type
                    - when set, also considers 'error-retrying' and
                    'queued' states.

    returns:    (ret1, ret2) - (True/False/None, "Error_String"/None)
                ret1:   True if a task has status as 'running', else
                        False if no task has status as 'running', or
                        None if exceptions were raised

                ret2:   None if no exceptions were raised, else
                        Error string 
    """
    is_running = False
    try:
        existing_tasks = None
        existing_tasks, err = get_tasks_by_cron_task_id(cron_task_id)
        if err is not None:
            raise Exception(err)
        if existing_tasks:
            for task in existing_tasks:
                # Check if a background task with the same cron_task_id is yet to complete its replication
                if check_execution is True and str(task['status']) in ['running', 'queued', 'error-retrying'] and str(task['task_type_id']) == str(task_type_id):
                    is_running = True
                elif check_execution is False and str(task['status']) in ['running'] and str(task['task_type_id']) == str(task_type_id):
                    is_running = True

    except Exception, e:
        return None, str(e)
    else:
        return is_running, None


def delete_cron(cron_task_id, user='root'):
    """Delete a cron by the cron_task_id."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        tasks, err = get_tasks_by_cron_task_id(cron_task_id)
        if err:
            raise Exception(err)
        cmd_list = []
        cmd_list.append(
            ['delete from cron_tasks where cron_task_id=%d' % cron_task_id])
        cmd_list.append(
            ['update tasks set status="cancelled" where cron_task_id=%s and status is not "completed"' % cron_task_id])
        if tasks:
            for task in tasks:
                cmd_list.append(
                    ['update subtasks set status="cancelled" where task_id=%d  and status is not "completed"' % task['task_id']])

        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)

        cron = crontab.CronTab(user)
        cron.remove_all(comment=str(cron_task_id))
        cron.write()
    except Exception, e:
        return False, "Error deleting cron entry : %s" % str(e)
    else:
        return True, None


def create_task(description, subtask_list, task_type_id=0, cron_task_id=0, node=socket.getfqdn(), initiate_time=None, attempts=3, run_as_user_name='root', retry_interval=1):
    """Adds a task in to tasks table which performs/runs the subtask_list according to the received arguments."""
    row_id = -1
    try:
        if not description or not subtask_list:
            raise Exception("Insufficient parameters")

        now = int(time.time())
        if not initiate_time:
            initiate_time = now

        log_path, err = config.get_log_folder_path()
        if err:
            raise Exception(err)
        log_dir = '%s/task_logs' % log_path
        if not os.path.isdir(log_dir):
            os.mkdir(log_dir)

        cmd = "insert into tasks (description,task_type_id, node, run_as_user_name, attempts, cron_task_id, retry_interval, create_time, initiate_time) VALUES ('%s','%d','%s','%s','%d','%d','%d', '%d', '%d');" % (
            description, task_type_id, node, run_as_user_name, attempts, int(cron_task_id), retry_interval, now, initiate_time)
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        row_id, err = db.execute_iud(db_path, [[cmd], ], get_rowid=True)
        if err:
            raise Exception(err)

        if row_id:
            log_file = '%s/%d.log' % (log_dir, row_id)
            for subtask in subtask_list:
                for description, command in subtask.iteritems():
                    command = '%s  &> %s' % (command, log_file)
                    cmd = "insert into subtasks (description,command,task_id) values ('%s','%s','%d');" % (
                        description, command, row_id)
                    status, err = db.execute_iud(
                        db_path, [[cmd], ], get_rowid=True)
                    if err:
                        raise Exception(
                            'Error creating scheduled command : %s' % err)
        else:
            raise Exception('Error creating scheduled task')
    except Exception, e:
        return False, ' Error adding task: %s' % e
    else:
        return True, None


def delete_task(task_id):
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        cmd_list = [['delete from tasks where task_id = %s' % task_id], [
            'delete from subtasks where task_id = %s' % task_id]]

        status, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing task : %s' % e
    else:
        return True, None


def delete_all_tasks():
    """Delete all entries from tasks and subtasks table

    """
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        cmd_list = [['delete from tasks'], [
            'delete from subtasks']]

        status, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing tasks: %s' % e
    else:
        return True, None


def delete_all_logs():
    try:
        logs_dir, err = config.get_log_folder_path()
        if err:
            raise Exception(err)
        paths = []
        paths.append('%s/cron_logs' % logs_dir)
        paths.append('%s/task_logs' % logs_dir)
        for path in paths:
            for root, dirs, files in os.walk(path):
                for f in files:
                    os.unlink(os.path.join(root, f))
                for d in dirs:
                    shutil.rmtree(os.path.join(root, d))

    except Exception, e:
        return False, 'Error removing all alerts : %s' % str(e)
    else:
        return True, None


def get_tasks(node=None):
    """Returns all entries from tasks table."""
    tasks = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        #start_time = int((datetime.datetime.now() - datetime.timedelta(minutes=minutes)).strftime("%s"))
        #end_time = int((datetime.datetime.now() + datetime.timedelta(minutes=minutes)).strftime("%s"))

        if not node:
            tasks_query = "select * from tasks order by initiate_time desc"
        else:
            tasks_query = "select * from scheduler_tasks order by initiate_time desc"

        tasks, err = db.get_multiple_rows(db_path, tasks_query)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving tasks : %s' % e
    else:
        return tasks, None


def get_tasks_by_cron_task_id(cron_task_id, get_last_by=False):
    tasks = []
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        if get_last_by is False:
            query = 'select * from tasks where cron_task_id="%d"' % int(
                cron_task_id)
        else:
            query = 'select * from tasks where cron_task_id="%d" order by "%s" desc limit 1' % (
                int(cron_task_id), str(get_last_by))

        tasks, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving tasks by cron task id: %s' % e
    else:
        return tasks, None


def get_task(task_id):
    """Get a particular entry with the passed task_id from the tasks table."""
    task = None
    try:

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        cmd = "select * from tasks where task_id=='%d'" % int(task_id)
        task, err = db.get_single_row(db_path, cmd)
        if err:
            raise Exception(err)
        if not task:
            raise Exception('Selected task not found')
    except Exception, e:
        return None, 'Error retrieving task details : %s' % e
    else:
        return task, None


def get_subtasks(task_id):
    """For the given task_id, fetch all the entires from subtasks with matching task_id value."""
    subtasks = None
    try:
        query = "select * from subtasks where task_id = '%d'" % task_id

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        subtasks, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)
        if not subtasks:
            raise Exception('No subtasks found for the specified task.')
    except Exception, e:
        return None, 'Error retrieving subtasks : %s' % e
    else:
        return subtasks, None


def process_tasks(node=socket.getfqdn()):
    """When called, processes/runs subtasks of each entry from tasks table if they satisfy/pass the required checks like status, last_run_time, retries, etc."""
    '''
    TODO
        - Needs a better docstring comment beriefly explaning what the function does
    '''
    try:

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        current_user = getpass.getuser()
        now = int(time.time())

        tasks_query = "select * from tasks where node == '" + node + \
            "' and (status == 'error-retrying' or status == 'queued') and (initiate_time <= '%d');" % (now)
        tasks_to_process, err = db.get_multiple_rows(db_path, tasks_query)
        if err:
            raise Exception(err)

        if tasks_to_process is not None:

            for task in tasks_to_process:

                if task['last_run_time']:
                    seconds_since_last_run = (now - task['last_run_time'])
                    # retry_interval is in minutes!
                    if seconds_since_last_run < task['retry_interval'] * 60:
                        continue

                # Mark the task as running
                cmd = "update tasks set status = 'running', last_run_time=%d where task_id = '%d'" % (
                    now, task['task_id'])
                status, err = db.execute_iud(
                    db_path, [[cmd], ], get_rowid=True)
                if err:
                    raise Exception(err)

                audit_str = "%s" % task['description']
                audit.audit("task_start", audit_str,
                            None, system_initiated=True)

                attempts = task['attempts']
                run_as_user_name = task['run_as_user_name']

                # Now process subtasks for the task
                subtasks_query = "select * from subtasks where task_id == '%d' and (status == 'error-retrying' or status == 'queued') order by subtask_id" % task[
                    'task_id']
                subtasks, err = db.get_multiple_rows(db_path, subtasks_query)
                if err:
                    raise Exception(err)

                # Assume task is complete unless proven otherwise
                task_completed = True

                # Iteriate through all the unfinished subtasks related to the
                # task
                for subtask in subtasks:

                    subtask_id = subtask["subtask_id"]

                    status_update = "update subtasks set status = 'running' where subtask_id = '%d' and status is not 'cancelled'" % subtask_id
                    status, err = db.execute_iud(
                        db_path, [[status_update], ], get_rowid=True)
                    if err:
                        task_completed = False
                        break

                    # Now actually execute the command
                    # This task is not to be meant to be executed by the
                    # current user so switch to that user
                    (out, return_code), err = command.execute_with_rc(
                        subtask["command"], shell=True, run_as_user_name=run_as_user_name)

                    if out[0]:
                        output = re.sub("'", "", ''.join(out[0]))
                    else:
                        output = None
                    if out[1]:
                        error = re.sub("'", "", ''.join(out[1]))
                    else:
                        error = None

                    if return_code == 0:
                        # This means the command was successful. So update to
                        # completed
                        status_update = "update subtasks set status = 'completed', return_code='%d' where subtask_id = '%d' and status is not 'cancelled';" % (
                            return_code, subtask_id)
                        status, err = db.execute_iud(
                            db_path, [[status_update], ], get_rowid=True)
                        if err:
                            task_completed = False
                            break
                        else:
                            continue
                    else:
                        # Subtask command failed
                        if attempts > 1 or attempts == -2:
                            status_update = 'update subtasks set status = "error-retrying", return_code="%d" where subtask_id = "%d" and status is not "cancelled";' % (
                                return_code, subtask_id)
                        elif attempts in [0, 1]:
                            status_update = 'update scheduler_commands set status = "failed", return_code="%d"" where subtask_id = "%d" and status is not "cancelled";' % (
                                return_code, subtask_id)
                        execute, err = db.execute_iud(
                            db_path, [[status_update], ], get_rowid=True)
                        task_completed = False
                        break

                if task_completed:
                    status_update = "update tasks set status = 'completed' where task_id = '%d'" % task[
                        'task_id']
                else:
                    if attempts > 1:
                        status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                            attempts - 1, task['task_id'])
                    elif attempts == -2:
                        status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                            -2, task['task_id'])
                    else:
                        status_update = "update tasks set status = 'failed', attempts = '%d' where task_id = '%d' and status is not 'cancelled'" % (
                            0, task['task_id'])
                status, err = db.execute_iud(
                    db_path, [[status_update], ], get_rowid=True)
                if err:
                    raise Exception(err)

                if task_completed:
                    audit.audit("task_complete", audit_str,
                                None, system_initiated=True)
                else:
                    audit.audit("task_fail", audit_str,
                                None, system_initiated=True)

    except Exception as e:
        return False, 'Error processing tasks : %s' % e
    else:
        return True, None


def main():
    # print add_cron_entry('ls -l', "Test entry",2,'*','*','*','*')
    # print get_all_cron_tasks()
    # process_tasks()
    # get_tasks()
    # print get_cron_task(1)
    # print delete_cron(1)
    # run_from_shell()
    # print delete_cron_with_comment("test spacing")
    #cron = None
    #cron =  find_cron("test")
    # for param in cron:
    #  print param.command
    #db_path,err = config.get_db_path()
    #clear_table = "delete from scheduler_commands;"
    #status,err = db.execute_iud(db_path,[[clear_table],],get_rowid=True)
    #clear_table = "delete from scheduler_tasks;"
    #status,err = db.execute_iud(db_path,[[clear_table],],get_rowid=True)
    #row = 1
    # for count in xrange(16,20):
    #  jobname = "Test_%d"%count
    #  if count < 18:
    #    status,err = schedule_a_job(db_path,jobname,[{'cmd1':'echo'},{'cmd2':'echo'},{'cmd3':'pwd'}])
    #    row = status
    #  else:
    #    status,err = schedule_a_job(db_path,jobname,[{'cmd1':'echo123'},{'cmd2':'ecdsfsdho'},{'cmd3':'spsdfawd'}],extra={'deleteble':1,})
    #  print status,err
    #status,err = schedule_a_job(db_path,"Test 20",[{'cmd1':'echo123'},{'cmd2':'ecdsfsdho'},{'cmd3':'spsdfawd'}],extra={'deleteble':1,'execute_after':row})
    # print execute_scheduler(db_path,node='gridcell-pri.integralstor.lan')
    # print get_background_jobs(db_path,node='gridcell-pri.integralstor.lan')
    # print delete_task(5)
    # print run_from_shell()
    # print delete_all_tasks()
    print is_task_running(1)


if __name__ == "__main__":
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
