
import json
import os
import shutil
import datetime
import sys
import re
import netifaces
import socket
import platform
import pprint
import integralstor_utils
from integralstor_utils import config, networking, command, disks, zfs, services_management

"""
The master.manifest file contains information about what the system configuration SHOULD be. Got by scanning the system at setup time or when requested by the admin.
The master.status file contains the status of the system components as of now. By comparing against the manifest, we can tell if something is missing or new.
"""


"""
Get all info and the status about all disks including any pool on disks
"""


def get_zfs_version():
    zfs_ver = ""
    try:
        #lines, err = command.get_command_output('dmesg | grep ZFS', shell=True)
        lines, err = command.get_command_output(
            "modinfo zfs | grep -iw -e version | cut -d ':' -f 2", shell=True)
        if err:
            zfs_ver = 'Could not determine..'
        if lines and lines[0]:
            zfs_ver = 'ZFS build ' + lines[0].strip()
        else:
            zfs_ver = 'Could not determine..'
    except Exception, e:
        return None, 'Error retrieving ZFS information : %s' % str(e)
    else:
        return zfs_ver, None


def get_disk_info_and_status():

    all_disks = None
    try:
        all_disks, err = disks.get_disk_info_all()
        if err:
            raise Exception(err)

        if all_disks:
            pool_list, err = zfs.get_pools()
            if pool_list:
                for sn, disk in all_disks.items():
                    id = disk['id']
                    found = False
                    for pool in pool_list:
                        devices_list, err = zfs.get_disks_in_component(
                            pool['config']['pool']['root'])
                        if err:
                            raise Exception(err)
                        if devices_list and id in devices_list:
                            disk['pool'] = pool['pool_name']
    except Exception, e:
        return None, 'Error retrieving disk information and status : %s' % str(e)
    else:
        return all_disks, None


def get_pool_status():
    """Get status of all zfs pools."""
    pl = None
    try:
        pl, err = zfs.get_pools()
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving pool status : %s' % str(e)
    else:
        return pl, None


def get_interface_status():
    """Gets a more concise version of the interface info and status than networking provides."""
    d = {}
    try:
        ifaces, err = networking.get_interfaces()
        if err:
            raise Exception(err)
        # print ifaces
        if ifaces:
            for iface_name, iface in ifaces.items():
                td = {}
                td['hwaddr'] = iface['addresses']['AF_LINK'][0]['addr']
                td['up'] = iface['up_status']
                if 'AF_INET' in iface['addresses'] and iface['addresses']['AF_INET'] and iface['addresses']['AF_INET'][0]:
                    inet_list = []
                    for inet in iface['addresses']['AF_INET']:
                        inet_dict = {}
                        if 'addr' in inet:
                            inet_dict['address'] = inet['addr']
                        if 'netmask' in inet:
                            inet_dict['netmask'] = inet['netmask']
                        if 'broadcast' in inet:
                            inet_dict['broadcast'] = inet['broadcast']
                        inet_dict['label'] = iface_name
                        inet_list.append(inet_dict)
                    td['inet'] = inet_list
                if 'bonding_master' in iface:
                    td['bonding_master'] = True
                if 'slave_to' in iface:
                    td['slave_to'] = iface['slave_to']
                if 'carrier_status' in iface:
                    td['carrier_status'] = iface['carrier_status']
                if 'bootproto' in iface:
                    td['boot_proto'] = iface['bootproto']
                d[iface_name] = td
    except Exception, e:
        return None, 'Error retrieving interface status : %s' % str(e)
    else:
        return d, None


def get_load_avg():
    """The load averages for the system along with the number of cores in order to tell if the averages are within bounds."""
    d = {}
    try:
        with open('/proc/loadavg', 'r') as f:
            line = f.readline()
            parts = line.split()
            if parts:
                d['1-min'] = float(parts[0])
                d['5-min'] = float(parts[1])
                d['15-min'] = float(parts[2])
        cores, err = _get_cpu_cores()
        if err:
            raise Exception(err)
        d["cpu_cores"] = int(cores)
    except Exception, e:
        return None, 'Error retrieving load average and CPU cores info : %s' % str(e)
    else:
        return d, None


def _get_cpu_cores():
    """Gets the number of cpu cores."""
    cores = -1
    try:
        with open('/proc/cpuinfo', 'r') as f:
            lines = f.readlines()
            for line in lines:
                ret = re.match('\s*cpu cores\s*:[\s]*([\d]+)$', line.strip())
                if ret:
                    grps = ret.groups()
                    if grps:
                        cores = int(grps[0].strip())
    except Exception, e:
        return None, 'Error retrieving CPU cores information: %s' % str(e)
    else:
        return cores, None


def get_mem_info():
    """The total and the used memory information."""
    ret = {}
    try:
        mem_total = None
        mem_free = None
        with open('/proc/meminfo', 'r') as f:
            lines = f.readlines()
            for line in lines:
                match = re.match(
                    'MemTotal\s*:\s+([\S]+)\s+(\S+)$', line.strip())
                if match:
                    grps = match.groups()
                    if grps:
                        mem_total = {}
                        mem_total['unit'] = grps[1]
                        mem_total['value'] = int(grps[0])
                        if mem_total['unit'] == 'kB':
                            mem_total['unit'] = 'GB'
                            mem_total['value'] = float(
                                mem_total['value']) / 1024 / 1024
                        elif mem_total['unit'] == 'mB':
                            mem_total['unit'] = 'GB'
                            mem_total['value'] = float(
                                mem_total['value']) / 1024
                match = re.match(
                    'MemFree\s*:\s+([\S]+)\s+(\S+)$', line.strip())
                if match:
                    grps = match.groups()
                    if grps:
                        mem_free = {}
                        mem_free['unit'] = grps[1]
                        mem_free['value'] = int(grps[0])
                        if mem_free['unit'] == 'kB':
                            mem_free['unit'] = 'GB'
                            mem_free['value'] = float(
                                mem_free['value']) / 1024 / 1024
                        elif mem_free['unit'] == 'mB':
                            mem_free['unit'] = 'GB'
                            mem_free['value'] = float(
                                mem_total['value']) / 1024
                if mem_total and mem_free:
                    break
        if not mem_total and not mem_free:
            raise Exception('Error retrieving memory information')
        ret['mem_total'] = mem_total
        ret['mem_free'] = mem_free
    except Exception, e:
        return None, 'Error retrieving memory information: %s' % str(e)
    else:
        return ret, None


def get_services_status():
    """The status of various services."""
    s = {}
    try:
        platform, err = config.get_platform()
        if err:
            raise Exception(err)
        if platform == 'gridcell':
            # Commenting out ctdb for now as we wont use it for this release!
            #services = ['smb', 'winbind', 'ctdb', 'glusterd']
            services = ['smb', 'winbind', 'glusterd']
            for service_name in services:
                stat, err = command.get_command_output(
                    '/sbin/service %s status' % service_name)
                ret = None
                rc = -1
                tup, err = command.execute_with_rc(
                    '/sbin/service %s status' % service_name)
                if tup:
                    (ret, rc) = tup
                if err:
                    raise Exception(err)
                if rc == 0:
                    lines, er = command.get_output_list(ret)
                    if er:
                        raise Exception(er)
                    s[service_name] = [0, ','.join(lines)]
                else:
                    err = ''
                    tl, er = command.get_output_list(ret)
                    if er:
                        raise Exception(er)
                    if tl:
                        err = ','.join(tl)
                    tl, er = command.get_error_list(ret)
                    if er:
                        raise Exception(er)
                    if tl:
                        err = err + ','.join(tl)
                    s[service_name] = [-1, err]
        else:
            service_dict, err = services_management.get_sysd_services_status()
            if err:
                raise Exception(err)
            for service_name, service_info in service_dict.items():
                if service_info['info']['status']['status_str'] in ['Failed', 'Unknown State']:
                    s[service_name] = [-1, service_info['info']
                                       ['status']['output_str']]
                else:
                    s[service_name] = [
                        0, service_info['info']['status']['output_str']]
    except Exception, e:
        return None, 'Error retrieving services status: %s' % str(e)
    else:
        return s, None


def get_cpu_model():
    """The kind of CPU that we're running on."""
    cpu_model = None
    try:
        with open('/proc/cpuinfo', 'r') as f:
            lines = f.readlines()
            for line in lines:
                ret = re.match('\s*model name\s*:([\S\s]+)$', line.strip())
                if ret:
                    grps = ret.groups()
                    if grps:
                        cpu_model = grps[0]
                        break
    except Exception, e:
        return None, 'Error retrieving CPU model : %s' % str(e)
    else:
        return cpu_model, None


def get_ipmi_status():
    """Hardware status using IPMI."""
    ipmi_status = []
    try:
        fil = os.popen("ipmitool sdr")
        str4 = fil.read()
        lines = re.split("\r?\n", str4)
        ipmi_status = []
        for line in lines:
            l = line.rstrip()
            if not l:
                continue
            # print l
            comp_list = l.split('|')
            comp = comp_list[0].strip()
            status = comp_list[2].strip()
            hw_platform, err = config.get_hardware_platform()
            if status != "ns":
                if hw_platform and hw_platform == 'dell':
                    if ('fan' not in comp.lower()) and ('PS' not in comp) and ('voltage' not in comp.lower()) and ('current' not in comp.lower()) and (comp not in ['Inlet Temp', 'CMOS Battery', 'Pwr Consumption', 'Temp']):
                        continue
                td = {}
                td["parameter_name"] = comp_list[0].strip()
                td["reading"] = comp_list[1].strip()
                td["status"] = comp_list[2].strip()
                '''
        if comp in ["CPU Temp", "CPU1 Temperature"]:
          td["parameter_name"] = "CPU Temperature"
          td["component_name"] = "CPU"
        elif comp in ["System Temp", "MB1 Temperature"]:
          td["parameter_name"] = "System Temperature"
          td["component_name"] = "System"
        elif comp == "DIMMA1 Temp":
          td["parameter_name"] = "Memory card 1 temperature"
          td["component_name"] = "Memory card 1"
        elif comp == "DIMMA2 Temp":
          td["parameter_name"] = "Memory card 2 temperature"
          td["component_name"] = "Memory card 2"
        elif comp == "DIMMA3 Temp":
          td["parameter_name"] = "Memory card 3 temperature"
          td["component_name"] = "Memory card 3"
        elif comp == "FAN1":
          td["parameter_name"] = "Fan 1 speed"
          td["component_name"] = "Fan 1"
        elif comp == "FAN2":
          td["parameter_name"] = "Fan 2 speed"
          td["component_name"] = "Fan 2"
        elif comp == "FAN3":
          td["parameter_name"] = "Fan 3 speed"
          td["component_name"] = "Fan 3"
        elif comp == "CPU_FAN1":
          td["parameter_name"] = "CPU Fan"
          td["component_name"] = "CPU Fan"
        '''
                ipmi_status.append(td)
    except Exception, e:
        return None, 'Error retrieving IPMI information: %s' % str(e)
    else:
        return ipmi_status, None


def get_hardware_specific_info():
    return_dict = {}
    try:
        hw_platform, err = config.get_hardware_platform()
        if hw_platform:
            return_dict['hw_platform'] = hw_platform
            if hw_platform == 'dell':
                return_dict['hw_platform'] = 'dell'
                from integralstor_utils.platforms import dell
                idrac_url, err = dell.get_idrac_addr()
                if idrac_url:
                    return_dict['idrac_url'] = idrac_url
    except Exception, e:
        return None, 'Error retrieving hardware specific information: %s' % str(e)
    else:
        return return_dict, None



def get_status():
    """Overall status info about the system combining all of the above into one big dict."""
    d = {}
    try:
        zfs_ver, err = get_zfs_version()
        if err:
            raise Exception(err)
        d["zfs_version"] = zfs_ver

        os_ver = '%s %s' % (platform.system(), platform.release())
        d["os_version"] = os_ver

        dis, err = get_disk_info_and_status()
        if err:
            raise Exception(err)
        d["disks"] = dis

        services_stat, err = get_services_status()
        if err:
            raise Exception(err)
        d["services"] = services_stat

        iface_status, err = get_interface_status()
        if err:
            raise Exception(err)
        d["interfaces"] = iface_status

        pl, err = zfs.get_pools()
        if err:
            raise Exception(err)
        d["pools"] = pl

        lavg, err = get_load_avg()
        if err:
            raise Exception(err)
        d["load_avg"] = lavg

        meminfo, err = get_mem_info()
        if err:
            raise Exception(err)
        d["memory"] = meminfo

        ipmi, err = get_ipmi_status()
        if ipmi:
            d["ipmi_status"] = ipmi

        cm, err = get_cpu_model()
        if err:
            raise Exception(err)
        d["cpu_model"] = cm

        fqdn = socket.getfqdn()
        d["fqdn"] = fqdn

        hardware_dict, err = get_hardware_specific_info()
        if err:
            raise Exception(err)
        d["hardware_specific_dict"] = hardware_dict

    except Exception, e:
        return None, 'Error retrieving system status: %s' % str(e)
    else:
        return d, None


def generate_manifest_info():
    """Generate a dictionary containing all manifest information. Will be dumped into the master.manifest file in a json format."""
    manifest_dict = {}
    try:
        #pp = pprint.PrettyPrinter(indent=4)

        use_salt, err = config.use_salt()
        if err:
            raise Exception(err)
        fqdn = socket.getfqdn()
        if use_salt:
            import salt.modules.network
            import salt.modules.ps
            import salt.modules.status
            import salt.client
            import salt.wheel
            import salt.config
            local = salt.client.LocalClient()

            cfg, err = config.get_salt_master_config()
            if err:
                raise Exception(err)
            opts = salt.config.master_config(cfg)
            wheel = salt.wheel.Wheel(opts)
            keys = wheel.call_func('key.list_all')
            if not keys:
                raise Exception('No GRIDCells found!')
            nodes = keys['minions']
            # print nodes
            for node in nodes:
                manifest_dict[node] = {}

            roles = local.cmd('*', 'grains.item', ['roles'])
            for node, info in roles.items():
                if node not in manifest_dict:
                    manifest_dict[node] = {}
                manifest_dict[node]['roles'] = info['roles']
            ret = local.cmd('*', 'integralstor.status')
            for node, info in ret.items():
                if node not in manifest_dict:
                    manifest_dict[node] = {}
                manifest_dict[node]['cpu_model'] = info['cpu_model']
                manifest_dict[node]['disks'] = info['disks']
                for dn, dv in manifest_dict[node]['disks'].items():
                    if 'pool' in dv:
                        dv.pop('pool')
                manifest_dict[node]['interfaces'] = info['interfaces']
                manifest_dict[node]['memory'] = info['memory']
                manifest_dict[node]['fqdn'] = info['fqdn']
                if 'hardware_specific_dict' in info:
                    manifest_dict[node]['hardware_specific_dict'] = info['hardware_specific_dict']
        else:
            # Single node so get the info using a direct call and just bung it
            # into the fqdn key!
            manifest_dict[fqdn] = {}
            status_dict, err = get_status()
            if err:
                raise Exception(err)
            manifest_dict[fqdn]['cpu_model'] = status_dict['cpu_model']
            manifest_dict[fqdn]['disks'] = status_dict['disks']
            for dn, dv in manifest_dict[fqdn]['disks'].items():
                if 'pool' in dv:
                    dv.pop('pool')
            manifest_dict[fqdn]['interfaces'] = status_dict['interfaces']
            manifest_dict[fqdn]['memory'] = status_dict['memory']
            manifest_dict[fqdn]['fqdn'] = fqdn

        # Remove transitory info and only keep the actual hardware info
        for node in manifest_dict.keys():
            if 'interfaces' in manifest_dict[node]:
                for int_name, interface in manifest_dict[node]['interfaces'].items():
                    if 'up' in interface:
                        interface.pop('up')
                    if 'inet' in interface:
                        interface.pop('inet')
            if 'disks' in manifest_dict[node]:
                for disk_name, diskinfo in manifest_dict[node]['disks'].items():
                    if 'status' in diskinfo:
                        diskinfo.pop('status')
            if 'memory' in manifest_dict[node]:
                if 'mem_free' in manifest_dict[node]['memory']:
                    manifest_dict[node]['memory'].pop('mem_free')

        if not manifest_dict:
            raise Exception('Error getting manifest information')

    except Exception, e:
        return None, 'Error generating the manifest dictionary : %s' % str(e)
    else:
        return manifest_dict, None


def _convert_to_status_interface_dict(if_dict):
    id = {}
    try:
        # print 'interface info - ', if_dict
        id["status"] = if_dict["up"]
        if 'bonding_master' in if_dict:
            id['bonding_master'] = True
        if 'slave_to' in if_dict:
            id['slave_to'] = if_dict['slave_to']
        if 'carrier_status' in if_dict:
            id['carrier_status'] = if_dict['carrier_status']
        if "inet" in if_dict:
            id["inet"] = if_dict["inet"]
        if 'boot_proto' in if_dict and if_dict['boot_proto'] and if_dict['boot_proto'] in ['static', 'dhcp']:
            id['ip_configured'] = True
    except Exception, e:
        return None, 'Error converting to status interface dict : %s' % str(e)
    else:
        return id, None


"""
Generate a dictionary containing all status information. Will be dumped into the master.status file in a json format.
"""


def generate_status_info(path):
    status_dict = None
    try:
        pp = pprint.PrettyPrinter(indent=4)

        # First load the status
        fqdn = socket.getfqdn()
        use_salt, err = config.use_salt()
        if err:
            raise Exception(err)
        if use_salt:
            import salt.client
            local = salt.client.LocalClient()
            sd = local.cmd('*', 'integralstor.status')
        else:
            tmpsd, err = get_status()
            if err:
                raise Exception(err)
            sd = {}
            sd[fqdn] = tmpsd

        # pp.pprint(sd)
        if not sd:
            raise Exception('Did not get a response from salt')
        # pp.pprint(sd[fqdn]['interfaces'])

        # Load the manifest to check for discrepencies
        try:
            with open(path, 'r') as f:
                md = json.load(f)
        except Exception, e:
            raise Exception('Error reading the manifest file : %s' % str(e))
        # pp.pprint(md)

        status_dict = {}

        # Match the status against the manifest entries for discrepencies
        for hostname, manifest in md.items():
            # print hostname, len(hostname)
            temp_d = {}
            temp_d["errors"] = []
            node_status = 0
            # print sd.keys()

            if hostname not in sd.keys():
                node_status = -1
                # print "Not found in sd"
            else:
                if sd[hostname] and 'hardware_specific_dict' in sd[hostname]:
                    temp_d['hardware_specific_dict'] = sd[hostname]['hardware_specific_dict']

                # Process disk information
                disks = {}
                for disk_sn, disk in manifest["disks"].items():
                    # print disk_sn
                    # print sd[hostname]['disks'].keys()
                    dd = {}
                    if disk_sn in sd[hostname]["disks"]:
                        dd["status"] = sd[hostname]["disks"][disk_sn]["status"]
                        if dd['status']:
                            if 'hw_raid' in disk and (not disk['hw_raid']):
                                if (dd["status"] not in ['PASSED', 'OK']):
                                    node_status = 1
                                    temp_d["errors"].append(
                                        "Disk with serial number %s is reporting SMART errors." % disk_sn)
                            elif dd["status"].lower() != 'ok':
                                node_status = 1
                                temp_d["errors"].append(
                                    "Disk with serial number %s has errors." % disk_sn)
                        dd["name"] = sd[hostname]["disks"][disk_sn]["name"]
                    else:
                        sd[hostname]['disks'][disk_sn] = disk
                        sd[hostname]['disks'][disk_sn]['status'] = 'Disk missing'
                        dd["status"] = "Disk Missing"
                        node_status = 1
                        temp_d["errors"].append(
                            "Disk with serial number %s seems to be missing." % disk_sn)
                    disks[disk_sn] = dd
                new_disk = False
                for td in sd[hostname]["disks"].keys():
                    if td not in manifest["disks"]:
                        new_disk = True
                        temp_d["errors"].append(
                            "New disk detected. Disk with serial number %s  seems to be new." % td)
                        node_status = 2
                #temp_d["disks"] = disks
                temp_d["disks"] = sd[hostname]['disks']
                # pp.pprint(temp_d['disks'])

                if sd[hostname]['services']:
                    for service_name, service_info in sd[hostname]['services'].items():
                        if service_info[0] != 0:
                            temp_d['errors'].append(
                                'Service %s seems to have failed.' % service_name)
                            node_status = 1
                    temp_d["services"] = sd[hostname]['services']

                # Process interface information
                interfaces = {}
                for ifname, ifdict in manifest["interfaces"].items():
                    # Check for all initially present interfaces
                    id = {}
                    if ifname in sd[hostname]["interfaces"]:
                        id, err = _convert_to_status_interface_dict(
                            sd[hostname]["interfaces"][ifname])
                        if err:
                            raise Exception(err)
                    else:
                        id["status"] = "Interface Missing"
                        node_status = 1
                        temp_d["errors"].append(
                            "Interface with number %s seems to be missing." % ifname)
                    interfaces[ifname] = id
                for ifname, ifinfo in sd[hostname]["interfaces"].items():
                    # Check for all newly created interfaces - bonds, vlans, etc
                    # print 'ifname is ', ifname
                    if ifname not in manifest["interfaces"]:
                        id, err = _convert_to_status_interface_dict(
                            sd[hostname]["interfaces"][ifname])
                        if err:
                            raise Exception(err)
                        interfaces[ifname] = id
                temp_d["interfaces"] = interfaces

                for ifname, id in temp_d['interfaces'].items():
                    if ('ip_configured' in id or 'slave_to' in id)and id["status"] != 'up':
                        node_status = 1
                        temp_d["errors"].append(
                            "Interface %s is not up." % ifname)

                # print 'interfaces are ', temp_d['interfaces']

                if "memory" in sd[hostname]:
                    if sd[hostname]["memory"]["mem_total"]["unit"] == "kB":
                        sd[hostname]["memory"]["mem_total"]["value"] = str(
                            int(sd[hostname]["memory"]["mem_total"]["value"]) / 1024)
                        sd[hostname]["memory"]["mem_total"]["unit"] = "MB"
                    if sd[hostname]["memory"]["mem_free"]["unit"] == "kB":
                        sd[hostname]["memory"]["mem_free"]["value"] = str(
                            int(sd[hostname]["memory"]["mem_free"]["value"]) / 1024)
                        sd[hostname]["memory"]["mem_free"]["unit"] = "MB"
                    temp_d["memory"] = sd[hostname]["memory"]
                if "disk_usage" in sd[hostname]:
                    temp_d["disk_usage"] = sd[hostname]["disk_usage"]
                if "pools" in sd[hostname]:
                    temp_d["pools"] = sd[hostname]["pools"]
                if "load_avg" in sd[hostname]:
                    # To get around a django quirk of not recognising hyphens
                    # in dicts
                    sd[hostname]["load_avg"]["15_min"] = sd[hostname]["load_avg"]["15-min"]
                    sd[hostname]["load_avg"]["5_min"] = sd[hostname]["load_avg"]["5-min"]
                    sd[hostname]["load_avg"]["1_min"] = sd[hostname]["load_avg"]["1-min"]
                    sd[hostname]["load_avg"].pop("15-min", None)
                    sd[hostname]["load_avg"].pop("5-min", None)
                    sd[hostname]["load_avg"].pop("1-min", None)
                    temp_d["load_avg"] = sd[hostname]["load_avg"]

                if "cpu_model" in manifest:
                    temp_d["cpu_model"] = manifest["cpu_model"]

                if "fqdn" in manifest:
                    temp_d["fqdn"] = manifest["fqdn"]

                if 'ipmi_status' in sd[hostname]:
                    temp_d["ipmi_status"] = sd[hostname]["ipmi_status"]

                if temp_d["load_avg"]['15_min'] >= temp_d["load_avg"]['cpu_cores']:
                    temp_d["errors"].append(
                        "The 15-minute load average (%.2f) has been high." % temp_d["load_avg"]['15_min'])
                    # node_status = 1
                if temp_d["load_avg"]['5_min'] >= temp_d["load_avg"]['cpu_cores']:
                    temp_d["errors"].append(
                        "The 5-minute load average (%.2f) has been high." % temp_d["load_avg"]['5_min'])

                if 'ipmi_status' in temp_d:
                    for status_item in temp_d['ipmi_status']:
                        if status_item["status"] not in ['ok', 'nr']:
                            temp_d["errors"].append('The %s of the %s is reporting errors' % (
                                status_item["parameter_name"], status_item["component_name"]))

                pools = temp_d["pools"]
                component_status_dict, err = zfs.get_all_components_status(
                    pools)
                if err:
                    raise Exception(err)
                if component_status_dict:
                    for pool_name, component_status_list in component_status_dict.items():
                        msg = None
                        for component in component_status_list:
                            if 'status' in component and 'state' in component['status'] and component['status']['state'] != 'ONLINE':
                                if not msg:
                                    msg = "The ZFS pool '%s' has the following issue(s) : " % pool_name
                                msg += "The component %s of type '%s' has a state of '%s'. " % (
                                    component['name'], component['type'], component['status']['state'])
                        if msg:
                            temp_d['errors'].append(msg)

                temp_d['zfs_version'] = sd[hostname]['zfs_version']
                temp_d['os_version'] = sd[hostname]['os_version']

            temp_d["node_status"] = node_status
            if node_status == 0:
                temp_d["node_status_str"] = "Healthy"
            elif node_status == 1:
                temp_d["node_status_str"] = "Degraded"
            elif node_status == 2:
                temp_d["node_status_str"] = "New on-node hardware detected"
            elif node_status == -1:
                temp_d["node_status_str"] = "No response. Down?"
                temp_d['errors'].append('Node %s seems to be down' % hostname)

            status_dict[hostname] = temp_d
            # print status_dict[hostname]["errors"]
        # pp.pprint(status_dict)
    except Exception, e:
        return None, 'Error generating status : %s' % str(e)
    else:
        return status_dict, None


def main():
    pp = pprint.PrettyPrinter(indent=4)
    #local = salt.client.LocalClient()
    #data = local.cmd('*', 'grains.item', ['hwaddr_interfaces', 'mem_total', 'fqdn', 'cpu_model', 'roles'])
    # print data
    # print generate_manifest_info()
    # generate_status_info()
    # print get_ipmi_status()
    # print get_mem_info()
    # print get_interface_status()
    # pp.pprint(get_status())
    # pp.pprint(generate_manifest_info())
    # pp.pprint(get_interface_status())
    # pp.pprint(get_services_status())
    #ret, err = generate_manifest_info()
    # print ret, err
    # print ret.keys()
    # pp.pprint(get_interface_status())
    # pp.pprint(get_disk_info_and_status())
    # print zfs_version()
    # generate_status_info('/opt/integralstor/integralstor/config/status/master.manifest')
    pp.pprint(generate_status_info(
        '/opt/integralstor/integralstor/config/status/master.manifest'))
    # pp.pprint(generate_status_info('/opt/integralstor/integralstor_gridcell/config/status/master.manifest'))
    # generate_status_info('/opt/integralstor/integralstor_gridcell/config/status/master.manifest')
    #r, err = generate_status_info('/opt/integralstor/integralstor/config/status/master.manifest')
    # print r, err
    # if err:
    #  print err
    # print r.keys()
    # pp.pprint(r['integralstor-f678.integralstor.lan']['disks'])
    # pp.pprint(get_services_status())
    # print get_hardware_specific_info()


if __name__ == "__main__":
    ret = main()
    sys.exit(ret)

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
