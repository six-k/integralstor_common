from integralstor_utils import config, command

import os
import re
import shutil
import socket
import pwd
import grp

'''
SSL Related function
'''

"""
Return all the SSL certificates registered in the system's pki dir
"""


def get_ssl_certificates():
    cert_list = []
    try:
        certificates_dir, err = config.get_pki_dir()
        if err:
            raise Exception(err)
        if not certificates_dir:
            raise Exception('No certificates location defined')
        if not os.path.exists(certificates_dir):
            raise Exception('Certificates location does not exist')
        for dirname, dirnames, filenames in os.walk(certificates_dir):
            for subdirname in dirnames:
                cert_path = '%s/%s.cert' % (os.path.join(dirname,
                                                         subdirname), subdirname)
                key_path = '%s/%s.key' % (os.path.join(dirname,
                                                       subdirname), subdirname)
                if not os.path.exists(cert_path):
                    continue
                cert_info, err = parse_ssl_certificate(cert_path)
                if err:
                    continue
                d = {}
                d['name'] = subdirname
                d['certificate'] = cert_info
                cert_list.append(d)
    except Exception, e:
        return None, 'Error loading certificates : %s' % str(e)
    else:
        return cert_list, None


"""
Given a cert file, parse it and return a usable dict
"""


def parse_ssl_certificate(cert_location):
    cert_info = {}
    try:
        if not os.path.exists(cert_location):
            raise Exception('Could not locate certificate')
        lines, err = command.get_command_output(
            'openssl x509 -in %s -text -noout' % cert_location)
        if err:
            raise Exception(err)
        look_for = [{'srch_for': 'Not Before', 'field_name': 'expiry_start'}, {'srch_for': 'Issuer', 'field_name': 'issuer'}, {'srch_for': 'Not After', 'field_name': 'expiry_end'}, {'srch_for': 'Subject', 'field_name': 'dn'},  {
            'srch_for': 'Public Key Algorithm', 'field_name': 'key_algorithm'}, {'srch_for': 'Serial Number', 'field_name': 'serial_number'}, {'srch_for': 'Public-Key', 'field_name': 'key_length'}]
        for line in lines:
            for l in look_for:
                pattern = '[\s]*%s[\s]*:[\s]*([\S\s]*)$' % l['srch_for']
                ret = re.match(pattern, line)
                if ret:
                    grps = ret.groups()
                    if grps:
                        cert_info[l['field_name']] = grps[0]
        if 'key_length' in cert_info:
            ret = re.match('[\s]*\(([\sa-zA-Z0-9]*)\)',
                           cert_info['key_length'])
            if ret and ret.groups():
                cert_info['key_length'] = ret.groups()[0]
    except Exception, e:
        return None, 'Error parsing certificate : %s' % str(e)
    else:
        return cert_info, None


"""
Delete a cert directory from the pki dir
"""


def delete_ssl_certificate(name):
    try:
        pki_dir, err = config.get_pki_dir()
        if err:
            raise Exception(err)
        path = '%s/%s' % (pki_dir, name)
        if not os.path.exists(path):
            raise Exception('Specified certificate name does not exist')
        shutil.rmtree(path)
    except Exception, e:
        return False, 'Error deleting certificate : %s' % str(e)
    else:
        return True, None


def delete_all_ssl_certificates():
    error_list = []
    try:
        ssl_certs, err = get_ssl_certificates()
        if err:
            raise Exception(err)

        if ssl_certs:
            for cert in ssl_certs:
                if cert['name']:
                    ret, err = delete_ssl_certificate(str(cert['name']))
                    if err:
                        error_list.append(err)
        if error_list:
            raise Exception(str(error_list))
    except Exception, e:
        return False, str(e)
    else:
        return True, None


"""
Generates a self signed cert. Can be used temporarily for organisations internally.
"""


def generate_self_signed_ssl_certificate(d):
    try:
        pki_dir, err = config.get_pki_dir()
        if err:
            raise Exception(err)
        path = '%s/%s' % (pki_dir, d['name'])

        if os.path.exists(path):
            raise Exception('A key of that name already exists')

        cmd = 'openssl req -new -newkey rsa:'

        if 'key_length' in d:
            key_length = int(d['key_length'])
        else:
            key_length = 1024

        cmd = '%s%d' % (cmd, key_length)

        if 'days' in d:
            cmd = '%s -days %d' % (cmd, int(d['days']))

        subj = ''
        if 'country' in d:
            subj = '%s/C=%s' % (subj, d['country'])
        if 'state' in d:
            subj = '%s/ST=%s' % (subj, d['state'])
        if 'location' in d:
            subj = '%s/L=%s' % (subj, d['location'])
        if 'o' in d:
            subj = '%s/O=%s' % (subj, d['o'])
        if 'ou' in d:
            subj = '%s/OU=%s' % (subj, d['ou'])
        if 'cn' in d:
            subj = '%s/CN=%s' % (subj, d['cn'])
        if 'email' in d:
            subj = '%s/emailAddress=%s' % (subj, d['email'])

        cmd += ' -nodes -x509 -subj %s -keyout %s/%s.cert -out %s/%s.cert' % (
            subj, path, d['name'], path, d['name'])
        # print cmd

        os.mkdir(path)
        lines, err = command.get_command_output(cmd)
        if err:
            if os.path.exists(path):
                shutil.rmtree(path)
            raise Exception(err)

    except Exception, e:
        return False, 'Error generating self signed certificate : %s' % str(e)
    else:
        return True, None


"""
Upload an externally generated certificate.
"""


def upload_ssl_certificate(d):
    try:
        pki_dir, err = config.get_pki_dir()
        if err:
            raise Exception(err)
        path = '%s/%s' % (pki_dir, d['name'])

        if os.path.exists(path):
            raise Exception('A key of that name already exists')

        os.mkdir(path)
        with open('%s/%s.cert' % (path, d['name']), 'w') as f:
            f.write('-----BEGIN PRIVATE KEY-----\n')
            key_lines = d['private_key'].split()
            if key_lines:
                for line in key_lines:
                    f.write('%s\n' % line)
            f.write('-----END PRIVATE KEY-----\n')
            f.write('-----BEGIN CERTIFICATE-----\n')
            cert_lines = d['certificate'].split()
            if cert_lines:
                for line in cert_lines:
                    f.write('%s\n' % line)
            f.write('-----END CERTIFICATE-----\n')
    except Exception, e:
        return False, 'Error uploading certificate : %s' % str(e)
    else:
        return True, None


'''
SSH Related function
'''


def _get_ssh_dir(user):
    if user == "root":
        return '/%s/.ssh' % user
    else:
        return '/home/%s/.ssh' % user


def _get_public_key_file(user='replicator'):
    return '%s/id_rsa.pub' % (_get_ssh_dir(user))


def _get_private_key_file(user='replicator'):
    return '%s/id_rsa' % (_get_ssh_dir(user))


def _get_authorized_file(user='replicator'):
    return '%s/authorized_keys' % (_get_ssh_dir(user))


def _get_known_hosts(user='replicator'):
    return '%s/known_hosts' % (_get_ssh_dir(user))


def delete_fingerprints(user='replicator'):
    try:
        path = _get_known_hosts(user)
        with open(path, 'w') as f:
            pass
    except Exception, e:
        return False, str(e)
    else:
        return True, None


def delete_authorized_keys(user='replicator'):
    try:
        path = _get_authorized_file(user)
        with open(path, 'w') as f:
            pass
    except Exception, e:
        return False, str(e)
    else:
        return True, None


def delete_all_fingerprints():
    try:
        users, err = config.get_normal_users()
        if err:
            raise Exceptions(err)
        for user in users:
            path = _get_known_hosts(user)
            with open(path, 'w') as f:
                pass
    except Exception, e:
        return False, str(e)
    else:
        return True, None


def delete_all_authorized_keys():
    try:
        users, err = config.get_normal_users()
        if err:
            raise Exceptions(err)
        for user in users:
            path = _get_authorized_file(user)
            with open(path, 'w') as f:
                pass
    except Exception, e:
        return False, str(e)
    else:
        return True, None


def generate_ssh_key(user='replicator'):
    try:
        cmd = "ssh-keygen -t rsa -f %s -N ''" % (
            _get_ssh_dir(user) + "/id_rsa")
        runuser = "/bin/su -s /bin/bash -c \"%s\" %s " % (cmd, user)
        (ret, rc), err = command.execute_with_rc(runuser, True)
        if err:
            raise Exception(err)
        return True, None
    except Exception, e:
        return None, "Error while generating ssh file for user: %s. Error : %s" % (user, str(e))


def regenerate_ssh_key(user='replicator'):
    try:
        if os.path.isdir(_get_ssh_dir(user)):
            if os.path.isfile(_get_public_key_file(user)):
                os.remove('%s' % _get_public_key_file(user))
            if os.path.isfile(_get_private_key_file(user)):
                os.remove('%s' % _get_private_key_file(user))
        status, err = generate_ssh_key(user)
        if err:
            raise Exception(err)
        else:
            return True, None
    except Exception, e:
        return None, "Error regerating ssh key files : %s" % str(e)


def test_ssh(user='replicator', ip=None):
    try:
        if ip and user:
            cmd = "ssh %s@%s 'ls'" % (user, ip)
            (status, ret), err = command.get_command_output(cmd)
            if "anaconda-ks.cfg" in status:
                return True, None
            else:
                return "Key setup failed", "err"
        else:
            return "Username or IP not found", "err"
    except Exception, e:
        return False, "Error testing the ssh key check : %s" % str(e)


def update_ssh_dir_permissions(user='replicator'):
    try:
        # /bin/su -s /bin/bash -c \"%s\" %s
        uid = pwd.getpwnam(user).pw_uid
        gid = grp.getgrnam("integralstor").gr_gid

        path = _get_ssh_dir(user)
        os.chown(path, uid, gid)
        ssh_perm = "/bin/su -s /bin/bash -c 'chmod 700 %s' %s" % (path, user)
        (ret, rc), err = command.execute_with_rc(ssh_perm, True)
        if err:
            raise Exception(err)

        path = _get_authorized_file(user)
        if not os.path.isfile(path):
            with open(path, 'w') as f:
                f.close()

        os.chown(path, uid, gid)
        authorized_key = "/bin/su -s /bin/bash -c 'chmod 640 %s' %s" % (
            path, user)
        (ret, rc), err = command.execute_with_rc(authorized_key, True)
        if err:
            raise Exception(err)

        path = _get_known_hosts(user)
        if not os.path.isfile(path):
            with open(path, 'w') as f:
                f.close()
        if os.path.isfile(path):
            os.chown(path, uid, gid)
        return True, None
    except Exception, e:
        return False, "Error updating ssh dir permissions: %s" % str(e)


def get_ssh_key(user='replicator'):
    try:
        if not (os.path.isdir(_get_ssh_dir(user)) and os.path.isfile(_get_public_key_file(user)) and os.path.isfile(_get_private_key_file(user))):
            status, err = regenerate_ssh_key(user)
            if err:
                return False, "Error generating ssh key files. Please do the key generation manually"
        shutil.copyfile(_get_public_key_file(
            user), "/opt/integralstor/integralstor/integral_view/static/id_rsa.pub")
        return "id_rsa.pub", None
    except Exception, e:
        return False, "Error generating public key file: %s" % str(e)


def get_ssh_host_identity_key():
    try:
        shutil.copyfile("/etc/ssh/ssh_host_rsa_key.pub",
                        "/opt/integralstor/integralstor/integral_view/static/ssh_host_rsa_key.pub")
        return "ssh_host_rsa_key.pub", None
    except Exception, e:
        return False, "Error generating public key file: %s" % str(e)


def main():
    #d = {'name':'f', 'key_length': 2048, 'days': 100, 'country':'IN', 'state':'KA', 'location':'mumbai', 'o':'fractalio', 'cn':'www.fractalio.com', 'email':'a@fractalio.com'}
    d = {'name': 'g', 'country': 'IN', 'state': 'KA', 'location': 'mumbai',
         'o': 'fractalio', 'cn': 'www.fractalio.com', 'email': 'a@fractalio.com'}
    d1 = {'name': 'x', 'country': 'IN', 'state': 'KA', 'location': 'mumbai',
          'o': 'fractalio', 'cn': 'www.fractalio.com', 'email': 'a@fractalio.com'}
    # print generate_self_signed_ssl_certificate(d)
    # print generate_self_signed_ssl_certificate(d1)
    # print get_ssl_certificates()
    print regenerate_ssh_key('replicator')
    # print get_ssh_key()
    #add_key = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA3o29Pu4c5eLj1Yqm2gi8kHYaO8ckkl2CAoe5hSB8Zgn67LnCxD9PY+aWnmbYFCyqY/XBmU3uCNG0mYaBumv0qOkqgUo4/94NeP7f/JQhVqMeWE/Obi0L4fpbX7Rhva5VZr29d+syWv6Z9E30QstTL59dqw8jhrjaHbRCX3Ag7IXW3ydsYEI4em4ctrTTnl2Ucq7Na6NfrnoH/QRbaZZ7y3T8m6BoSTw6NQ0B5KPmOqRPKoEbmq767JobxaenVMcwSIhLmVd5v+HSZ7JMecrjJFmXcta2l6ibUlFLoIwHga09VtLnVrNb/dzL2PGGA7XiVVsFziKFkaRDJpCP89qZ4w== root@integralstor-c8a6.integralstor.lan'
    # print add_ssh_key(add_key,'root')
    # print test_ssh(ip='182.74.88.170')

    # print parse_ssl_certificate('/opt/integralstor/pki/a/b.cert')


if __name__ == '__main__':
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
